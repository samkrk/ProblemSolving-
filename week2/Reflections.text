PROBLEM #1 
Egg Cartons 

This problem sounds similar to one of the problems covered in the lectures where someone 
wanted to buy lottery tickets with no change. Just from observation we can see that if n is an odd 
number, it is impossible and we will return -1. Also from observation, if n>10 and an even number, 
it is always possible to form some combination. 
One approach to finding the number of 6-packs and 8-packs would be to first
    - check if n is even 
    - check if n = 6 or 8 
    - check that n > 10 
    - check if n is a multiple of 6 or 8 
    - keep subtracting 8 from n until it is a multiple of 6 then return the number 
      of times we subtracted 8 + the result/6. 

So I think this approach nearly worked but it doesn't always work for the minimum number of egg cartons. 
For example when n = 24, it returns 4 (4x6) instead of 3 (3x8). 
To solve this issue I could first be checking if it is a multipe of 8 before a multiple of 6, so that would 
fix the case where n = 24. 
But considering the case where n = 84, we can get 14 carton of 6 eggs, but we can also get 9 cartons of 8 
and 2 cartons of 6, for a total of 11 cartons. 
So clearly I need to remove the first condition where we return n/6 if n%6 == 1. 
I think my original approach might actually work if I just swap the last step around and subtract 6 from 
n until it is a multiple of 8, or we reach 0 and in that case the answer is just n/6. 

This method worked and passed all the test cases. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

PROBLEM #2 
Black and Red 

So after reading this problem, it sounds like we need to take some cards off the top of the deck, 
so that the number of black cards taken off the top will always be greater than the number of red cards. 
Maybe one way of solving this would be to just try the first position, go through the array, until 
the number of red cards is greater than the number of black, and then try again from the next card (provided 
the next card isn't a red). You could keep trying this method until it works, and it should always 
ensure that the answer is the smallest number of cards needed to cut. So some suedo-code could look like:
    - initialise red and black counter variables 
    - while we havent found where to split the deck 
        - loop through the array starting at index i, counting red and black cards 
        - If at any time there are more red than black, try again from the next card 
        - If we reach the end of the deck and we have met the requirement, we can return the index that we started 
          from in that iteration 

This approach worked on my first submission which was good. One thing to note is that i used the "continue" keyword which I 
don't think i've ever used before so that was interesting. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

PROBLEM #3
Derivative Sequence

This problem looks pretty straighforward. I think I will just use a nested loop, with the outer loop counting the 
number of derivaties (n), and the inner loop for calculating the difference. From the constraints we can see that we won't 
be given a value of n that exceeds the number of elements in the array, so we don't have to worry about this issue. 

Ended up using a temp array and a next_derivative array to complete this. Probably could have only used one temporary vector
for a more elegant solution but this way worked as well. 
Passed all tests on first submission which is good. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

PROBLEM #4 
Christmas Tree

This problem seems harder than the previous ones. I think one way to solve this problem could be using recursion. 
To start, consider the case where there is only one level, if we have at least one of each bauble, then there 
are three ways to decorate the tree. 
What I am unsure about, is if we have say 8 levels on the tree, but only 6 baubles, could we put one baubles in each 
row, or does each row have to be filled first before moving onto the next row. And if that is the case, then what if we had 
5 baubles and 3 rows, so the last row would not be filled. Does this mean we just consider the first two rows only, since 
the third can never be filled? 
Actually it says in the instructions that on row k we have to fill k baubles. So I guess if there aren't enough to 
fill out the last row, we discard those baubles and that row. 

So I think I will try a recursive approach, where for each bauble, we will initially try to put a red one up, then blue, 
then green, until we reach the end and then maybe we can back track, swapping the red for the blue, and going again, then 
eventually the greens, until we have exhausted all possible combinations that fit the decorating criterion. 

Honestly im not sure exactly how i would implement this recursive method. So maybe I could create an intermediate function 
that calculates all the possible combinations on any given level for how many baubles we have, and then I could just 
multiply the results from each level to get some total. This method would actually still be recursive I think. 

So I call the function for level 1, with r,b,g baubles, if we can put a red bauble down and it doesn't violate the rules,
then we call the function again for level 2, with r-1,b,g baubles.

After some more thinking, we only get a valid combination when the last row is completed, so this would be the base case 
of a recursive function. So if for any given row, we can check if we have a valid tree, we will be able to add 
combinations to the result. 

Unfortunately i was unable to solve this problem so I decided to move on to different problems. I will leave 
my thoughts in the logbook anyway. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

PROBLEM #5 
Elevator Limit

So we don't know how many people were in the elevator before the start of the simulation, but we can still determine the 
largest amount of people that entered the elevator during the simulation. We can compare the elements of entered and exited to 
determine a running tally of people in the elevator at each floor. This will give us a single vector of the number of people 
in the elevator during the simulation. So imagine the vector is something like {2,-5,4,20}, with the elevator capacity of 30 people. 
We know there must have been at least 5 people in the elevator before the simulation, and then the largest number 
of people in the elevator before the simulation would be 10, because 30-20=10. So the suedo-code for this would be something like
    - calculate enter[i] - exit[i] for each element 
    - max = physical limit - max(difference[])
        - if max < 0, this is impossible so we return 0. 
    - if min(difference[]) < 0, 
        - min = min[difference[]]
        - else min = 0
    
 This approach was almost correct but just needed a few changes. So becuase people exit before they enter, the way I was 
 calculating the tally was slightly wrong, as you need to subtract the amount of people who exit first, and then that gives 
 you the new minimum value. Other than that the method seems to work. 

 So after uploading this several times, there were a few test cases that I failed, so I needed to add some final 
 checks to ensure my answers made sense. I first added a check that made sure the minimum value was not larger than 
 the maximum and this solved one of my failed test cases. Then I added a check to ensure that max was not < 0. In 
 both of these cases I would just return an empty array, as clearly something was not possible about the test case. 
 After adding these changes, I was able to pass all test cases. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 PROBLEM #6
 Mooing Cows 

 So my initial thoughts on this problem are that we first want to extract the information from the input string arrays 
 and put it in a different form that is easier to work with. I will check each element in the arrays, if it is a '.', 
 I will set that to a 0 in a vector at that index, and if it is a 'C', I will make that a 1 in the same vector. 
 So now we will have a number of vectors with 0 and 1s, representing the positions of the cows. 

 Then we can use brute force to calculate the the dissatisfaction level for each cow, by using a nested loop to first 
 calculate the dissatisfaction of each cow in the same row as the cow mooing, where the horizontal distance can be 
 equal to the for loop index j, and the vertical distance can be the outer for loop index i. 

 So this is essentially what I did, using brute force to calculate the dissatisfaction of every cow from 
 every other cow. I didn't end up converting the strings to arrays of ints because this wasn't necessary, and 
 I could just check if we had a cow at the index by looking for 'C' or '.'. 
 I actually read the question slightly wrong and was trying to calculate the square root of the distance, which led 
 to me getting the test cases wrong. Also there was an issue with the way I was calculating the distance, as I was 
 comparing the distance between each cow and checking if it was the minimum, when I should have been adding the 
 distances from all the cows and then checking if it was the smallest dissatisfaction level. 

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 Final reflections

 I enjoyed problems 1,2,3 and 5, but was unable to solve the Christmas Tree problem and 
 was not overly happy with my solution for Mooing Cows. I spent a lot of time thinking about 
 the Christmas Tree problem so it kind of sucked that I couldn't even think of a basic solution. 
 As for the Mooing Cows problem, I used 4 nested loops in my solution, which just felt very wrong, 
 and this problem took longer than I would have liked given that it was meant to be the easiest 
 difficulty. 
 Overall I completed 5 problems this week which is good, but I do feel like I need to get better 
 at solving different types of problems, such as the Christmas Tree problem which probably involved 
 recursion or some other tactics to solve. 