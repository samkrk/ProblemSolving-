PROBLEM #1
Time Travelling Cellar

Unless there are other edge cases that i'm missing, it looks like we just need to find the difference between the largest element 
in profit and the smallest element in decay, provided they aren't at the same index. 

So I will, 
    find largest element in profit at index i. 
    loop through decay, skipping i, finding the minimum at index j 
    return profit[i]-decay[j]

This worked for almost all the test cases. My issue on my first submission was that I was initialising the min variable to the first 
element of decay, and in the case where this was the minimum and the maximum was also the first element, it would be wrong. 
To fix this, i just changed the min variable to the max variable that we just found. Since the result is always positive, this 
approach should work now. 

Now i've passed 94/100 test cases, but the algorithm fails in some specific edge cases. What sometimes happens, is its better 
to take the second largest value in profit, because the largest value in profit has a very small corresponding decay value. 
I guess one way to avoid this error could be to track the second largest value in profit as well. So if the second largest 
profit was at index k, the largest profit was at index i and we know the minimum decay value, we could check if 
profit[k] - decay[i] > profit[i] - min. If this is true we return the first part of the inequality and if its false 
we return what we were returning previously. 

So a slight issue with that approach was the way I initialised my second_max and second_index elements. They needed to be 
pointing to different values than the max and max_index variables to begin with. 

The final thing wrong with what I had was that my method of finding the second largest element only worked if the 
second largest element occured before the largest element in the array. 
My code is pretty unreadable at this point so im going to split in up into 3 arrays, first find the largest profit,
then second largest, then the min decay. 
This worked and I finally passed all the test cases. 


PROBLEM #2 
Paternity Test

So for this problem, the first thing we need to do is find which letters in the child don't match the mother. 
Once we have a list of the indexes that we need to check, we can compare them with all of the fathers DNAs at 
the respective indexes. If they do not match we continue with the next father, if they all match, we push back the 
index of the father in the resulting array. I'm not entirely sure if i've understood the question perfectly, 
but I will try to solve it anyway as I understand it. 
So some pseduo code for this approach could be 

Loop through mother DNA, 
    Where the childs DNA does not match the mothers, add the index of the DNA to a list called missing 

Loop through the men array 
    Loop through the missing array
        check missing.at(j) == man.at(i).at(j)
            if they dont match, skip this man 
            if they do match keep going 
    if we have a complete match, add this mans index i to the answer 

So I think I definitely did slightly misunderstand the question. I think I need to be checking 
if the father has at least half of the same DNA as the child first, then I can compare those possible 
fathers with the remainder of my algorithm.

This approach passed 90/100 test cases, but the issue was that I was returning the indexes of the possible 
fathers in the wrong array so some of the cases failed. To fix this I just created another vector which 
stored the indexes of the potential fathers in the men array. 


PROBLEM #3
Unseal the Safe

This problem seems pretty interesting given the range of possible inputs is very small. I feel like 
recursion could be used for the small cases, but when N approaches 30 and the possible 
combinations is in the millions or billions, this might be too slow. 





PROBLEM #4
Monsters Valley2

So the most expensive and worst case would be if we bribe all the monsters. We could use 
brute force to try every combination of bribing different monsters and then find the cheapest 
path that works. 

We have to bribe the first monster for some cost and that gives us some scariness level of 
our group of monsters. If our scariness level is greater than all the other monsters then we 
just return the cost. I guess if I was to use recursion this would be the base case.
So the recursive case would be we need to bribe some monsters 

Another thing I can see, is that if a monsters dread is greater than the sum of all that 
came before it, we have to bribe this monster. 
So we can get a subset of monsters that we must bribe in order to pass. 
Then with the remaining mosters, these can be walked pass if we have enough scariness. 
So for these remaining monsters, we want to minimise the cost needed to pass the monsters until 
we reach another one we have to buy.

Ok so I actually think the easiest way to do this it to just use a recursive brute force method 
and try every valid combination of monsters. So the base case of this recursive method is 
when there are no more monsters left in the vector. If there are monsters left, 
we first check that our scariness is greater than the monsters dread. If this is not the case 
then we have to bribe the monster. Once we have the option to walk past or bribe the monster, 
we recusively call the function in both cases, where we buy and we walk past, 
passing the scariness of our pack, and the remaining monsters and their prices as the 
inputs to the function. We can then return the cost of the cheaper one. 



End of week reflection 

Was really not happy with my performance on the first question. Had to submit it 5 times before i passed all the test cases. 
    

