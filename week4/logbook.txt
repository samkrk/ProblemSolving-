PROBLEM #1
Time Travelling Cellar

Unless there are other edge cases that i'm missing, it looks like we just need to find the difference between the largest element 
in profit and the smallest element in decay, provided they aren't at the same index. 

So I will, 
    find largest element in profit at index i. 
    loop through decay, skipping i, finding the minimum at index j 
    return profit[i]-decay[j]

This worked for almost all the test cases. My issue on my first submission was that I was initialising the min variable to the first 
element of decay, and in the case where this was the minimum and the maximum was also the first element, it would be wrong. 
To fix this, i just changed the min variable to the max variable that we just found. Since the result is always positive, this 
approach should work now. 

Now i've passed 94/100 test cases, but the algorithm fails in some specific edge cases. What sometimes happens, is its better 
to take the second largest value in profit, because the largest value in profit has a very small corresponding decay value. 
I guess one way to avoid this error could be to track the second largest value in profit as well. So if the second largest 
profit was at index k, the largest profit was at index i and we know the minimum decay value, we could check if 
profit[k] - decay[i] > profit[i] - min. If this is true we return the first part of the inequality and if its false 
we return what we were returning previously. 

So a slight issue with that approach was the way I initialised my second_max and second_index elements. They needed to be 
pointing to different values than the max and max_index variables to begin with. 

The final thing wrong with what I had was that my method of finding the second largest element only worked if the 
second largest element occured before the largest element in the array. 
My code is pretty unreadable at this point so im going to split in up into 3 arrays, first find the largest profit,
then second largest, then the min decay. 
This worked and I finally passed all the test cases. 


PROBLEM #2 
Paternity Test

So for this problem, the first thing we need to do is find which letters in the child don't match the mother. 
Once we have a list of the indexes that we need to check, we can compare them with all of the fathers DNAs at 
the respective indexes. If they do not match we continue with the next father, if they all match, we push back the 
index of the father in the resulting array. I'm not entirely sure if i've understood the question perfectly, 
but I will try to solve it anyway as I understand it. 
So some pseduo code for this approach could be 

Loop through mother DNA, 
    Where the childs DNA does not match the mothers, add the index of the DNA to a list called missing 

Loop through the men array 
    Loop through the missing array
        check missing.at(j) == man.at(i).at(j)
            if they dont match, skip this man 
            if they do match keep going 
    if we have a complete match, add this mans index i to the answer 

So I think I definitely did slightly misunderstand the question. I think I need to be checking 
if the father has at least half of the same DNA as the child first, then I can compare those possible 
fathers with the remainder of my algorithm.

This approach passed 90/100 test cases, but the issue was that I was returning the indexes of the possible 
fathers in the wrong array so some of the cases failed. To fix this I just created another vector which 
stored the indexes of the potential fathers in the men array. 


PROBLEM #3
Unseal the Safe

This problem seems pretty interesting given the range of possible inputs is very small. I feel like 
recursion could be used for the small cases, but when N approaches 30 and the possible 
combinations is in the millions or billions, this might be too slow. 

So after examining some of the examples and specific combinations, you can see that the number of 
combinations depends on the first button you press and obviously the length N. So the number 
of combinations starting on button 1 with length 3, which I will denote 1,3, is the sum of all 
the adjacent buttons with lenghs N-1. i.e. 2,2 and 4,2. So again 2,2 has combinations 1,1 3,1 and 5,1 
and for each button the total combination of password length 1 is 1.
So to find all combinations of passwords length 3, we sum up all the passwords of length three which 
start at each button, i.e.
result = 1,3 + 2,3 + 3,3 + ... + 0,3. 
And we can recursively figure out each of these by summing up the adjacent sides with length N-1. 
Here the base case is when N = 1, although I could use 2 since N will be between 2 and 30.

So this approach worked for values up to around N = 15, but at this point the program was taking ages to 
run. To fix this, I used memoistation and added a vector of vectors, memo, which stored the 
results of previous function calls. Now when I run the function for N = 30, it runs in almost no 
time at all. 

The code now worked and passed all the test cases. 



PROBLEM #4
Monsters Valley2

So the most expensive and worst case would be if we bribe all the monsters. We could use 
brute force to try every combination of bribing different monsters and then find the cheapest 
path that works. 

We have to bribe the first monster for some cost and that gives us some scariness level of 
our group of monsters. If our scariness level is greater than all the other monsters then we 
just return the cost. I guess if I was to use recursion this would be the base case.
So the recursive case would be we need to bribe some monsters 

Another thing I can see, is that if a monsters dread is greater than the sum of all that 
came before it, we have to bribe this monster. 
So we can get a subset of monsters that we must bribe in order to pass. 
Then with the remaining mosters, these can be walked pass if we have enough scariness. 
So for these remaining monsters, we want to minimise the cost needed to pass the monsters until 
we reach another one we have to buy.

Ok so I actually think the easiest way to do this it to just use a recursive brute force method 
and try every valid combination of monsters. So the base case of this recursive method is 
when there are no more monsters left in the vector. If there are monsters left, 
we first check that our scariness is greater than the monsters dread. If this is not the case 
then we have to bribe the monster. Once we have the option to walk past or bribe the monster, 
we recusively call the function in both cases, where we buy and we walk past, 
passing the scariness of our pack, and the remaining monsters and their prices as the 
inputs to the function. We can then return the cost of the cheaper one. 

So I was having this dumb issue where the scariness levels exceeded the INT_MAX value. So I added 
a check that ensured if our current scariness level was over 2,000,000 we could return 0 additional cost 
since that is above any monsters possible dread. 
Also, in my while loop which keeps bribing the monsters if we absolutely have to, I added a condition that 
if we had no more monsters left we just return our cost.

So this passed 97/100 test cases. The one that I could see failed didn't really look any different to 
the other test cases, and I was only off by 1 cost. I could see the inputs were all quite large so I just 
guessed it was another integer overflow causing the error. I added a check at the top 
of the recursive function that checked if the scariness was over 2000000000 or less than 0, and in 
this case we could just return 0 additional cost since we had enough scariness to walk past any 
monsters. 

This worked and I passed all the test cases. 


End of week reflection 

Was really not happy with my performance on the first question. Had to submit it 5 times 
before i passed all the test cases. Question 2 was okay considering I kind of misunderstood the 
question initially. Luckily the way I did the question meant I just had to add on some other 
functionality to my method and I then passed the tests soon after. I was really happy with question 3 
and that was probably the most interesting problem I've done so far in this course. I had a lot 
of fun trying to visualise the recursive relationship between the buttons and the lengths on paper. 
Also, that was the first time i've used memoistation to solve a problem and it was cool to see it 
improve the speed of the algorithm so dramatically. 
Question 4 felt pretty difficult intially and I was a bit stuck trying to figure out what 
approach to take. I wasn't sure if I should use recursion or brute force, but then I sort of 
realised that you could recursively brute force it and just try everything using recursion. 
Once I figured that out the code was actually pretty simple, except for the integer overflow issues 
that kept happening. But now I know to look out for those issues when we have inputs of that size. 
    

