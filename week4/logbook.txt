PROBLEM #1
Time Travelling Cellar

Unless there are other edge cases that i'm missing, it looks like we just need to find the difference between the largest element 
in profit and the smallest element in decay, provided they aren't at the same index. 

So I will, 
    find largest element in profit at index i. 
    loop through decay, skipping i, finding the minimum at index j 
    return profit[i]-decay[j]

This worked for almost all the test cases. My issue on my first submission was that I was initialising the min variable to the first 
element of decay, and in the case where this was the minimum and the maximum was also the first element, it would be wrong. 
To fix this, i just changed the min variable to the max variable that we just found. Since the result is always positive, this 
approach should work now. 

Now i've passed 94/100 test cases, but the algorithm fails in some specific edge cases. What sometimes happens, is its better 
to take the second largest value in profit, because the largest value in profit has a very small corresponding decay value. 
I guess one way to avoid this error could be to track the second largest value in profit as well. So if the second largest 
profit was at index k, the largest profit was at index i and we know the minimum decay value, we could check if 
profit[k] - decay[i] > profit[i] - min. If this is true we return the first part of the inequality and if its false 
we return what we were returning previously. 

So a slight issue with that approach was the way I initialised my second_max and second_index elements. They needed to be 
pointing to different values than the max and max_index variables to begin with. 

The final thing wrong with what I had was that my method of finding the second largest element only worked if the 
second largest element occured before the largest element in the array. 
My code is pretty unreadable at this point so im going to split in up into 3 arrays, first find the largest profit,
then second largest, then the min decay. 
This worked and I finally passed all the test cases. 


PROBLEM #2 
Paternity Test

So for this problem, the first thing we need to do is find which letters in the child don't match the mother. 
Once we have a list of the indexes that we need to check, we can compare them with all of the fathers DNAs at 
the respective indexes. If they do not match we continue with the next father, if they all match, we push back the 
index of the father in the resulting array. I'm not entirely sure if i've understood the question perfectly, 
but I will try to solve it anyway as I understand it. 
So some pseduo code for this approach could be 

Loop through mother DNA, 
    Where the childs DNA does not match the mothers, add the index of the DNA to a list called missing 

Loop through the men array 
    Loop through the missing array
        check missing.at(j) == man.at(i).at(j)
            if they dont match, skip this man 
            if they do match keep going 
    if we have a complete match, add this mans index i to the answer 

So I think I definitely did slightly misunderstand the question. I think I need to be checking 
if the father has at least half of the same DNA as the child first, then I can compare those possible 
fathers with the remainder of my algorithm.

This approach passed 90/100 test cases, but the issue was that I was returning the indexes of the possible 
fathers in the wrong array so some of the cases failed. To fix this I just created another vector which 
stored the indexes of the potential fathers in the men array. 


PROBLEM #3
Unseal the Safe



End of week reflection 

Was really not happy with my performance on the first question. Had to submit it 5 times before i passed all the test cases. 
    